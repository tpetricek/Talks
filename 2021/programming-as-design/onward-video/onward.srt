1
00:00:01,090 --> 00:00:06,280
Hello, my name is Tomas Petricek, and I want to talk about programming through the lens of architecture,

2
00:00:06,280 --> 00:00:12,490
design and urban planning. When we talk about programming, we use quite a lot of different metaphors.

3
00:00:12,490 --> 00:00:18,310
We talk about writing code, as if we were writing any other ordinary piece of text.

4
00:00:18,310 --> 00:00:23,350
We talk about software engineering as if programming was like building bridges.

5
00:00:23,350 --> 00:00:28,720
And I'm going to add architecture, design and urban planning to this vocabulary.

6
00:00:28,720 --> 00:00:34,540
But first, let me explain why does this actually make sense?

7
00:00:34,540 --> 00:00:44,020
Programming is a lot about dealing with complexity. I'm going to refer to Jane Jacobs, who wrote this excellent urban planning book in the 1960s,

8
00:00:44,020 --> 00:00:52,810
The Death and Life of Great American Cities, where she explains exactly why urban planning involves a lot of complexity.

9
00:00:52,810 --> 00:01:02,020
So, Jane Jacobs says we may wish for easier all-purpose analysis and for simpler, magic all-purpose cures,

10
00:01:02,020 --> 00:01:11,590
but wishing cannot change these problems into simpler matters, no matter how much we try to evade the realities and to handle them as something different.

11
00:01:11,590 --> 00:01:17,500
Jane Jacobs very much realises that architecture and urban planning have to deal

12
00:01:17,500 --> 00:01:22,750
with a lot of complexity in the system and programming is very much the same.

13
00:01:22,750 --> 00:01:30,700
That's one of the reasons why I think it's worthwhile looking at what's being done in this field and see what we can learn.

14
00:01:30,700 --> 00:01:39,280
But the interesting thing in Jane Jacobs is that she actually elaborate on what kind of complexity a city is.

15
00:01:39,280 --> 00:01:43,640
What kind of a problem city is?

16
00:01:43,640 --> 00:01:53,830
Jacobs uses or refers to a paper that analyses the history of science and looks at different eras in the history of science,

17
00:01:53,830 --> 00:02:03,130
where science has first learnt how to tackle problems of simplicity, which are problems, where you have a full analytical solution.

18
00:02:03,130 --> 00:02:09,670
So, Newtonian physics, for example, you can fully analyse everything.

19
00:02:09,670 --> 00:02:14,950
More difficult, more challenging problems are problems of disorganised complexity.

20
00:02:14,950 --> 00:02:24,520
So this is things like movement of molecules inside gas where you can't precisely simulate every single molecule.

21
00:02:24,520 --> 00:02:32,350
You can't calculate that, but you can apply some statistical methods to simplify and reduce the problem.

22
00:02:32,350 --> 00:02:36,970
And the most interesting problems in science are things like genes, gene expression.

23
00:02:36,970 --> 00:02:45,730
Those are problems of organised complexity, where you really have a lot of different things going on.

24
00:02:45,730 --> 00:02:52,060
And they're very complex. They're very complex processes. But there is no way to reduce the complexity.

25
00:02:52,060 --> 00:02:56,810
There's no way to get rid of it and abstract it away.

26
00:02:56,810 --> 00:03:05,500
Jane Jacobs points out that understanding cities and urban planning is exactly dealing with these problems of organised complexity.

27
00:03:05,500 --> 00:03:08,620
There's a lot of different processes,

28
00:03:08,620 --> 00:03:22,270
they're all interacting in subtle ways and you just can't reduce or, sort of, abstract away. Just work with average inhabitants of a city.

29
00:03:22,270 --> 00:03:32,470
Now, interestingly, a very similar structure, a very similar categorisation exists about software systems.

30
00:03:32,470 --> 00:03:43,750
And this is due to Dave Parnas, who wrote in 1985 a paper that looks at the US anti-ballistic missile software efforts,

31
00:03:43,750 --> 00:03:55,510
attempts to build a system, and tries to argue why this is very hard or, possibly, why such a system cannot even be built.

32
00:03:55,510 --> 00:04:01,600
He opens the paper by looking at the kind of a problem that software is.

33
00:04:01,600 --> 00:04:06,280
This has a very similar structure to what Jane Jacobs is doing.

34
00:04:06,280 --> 00:04:12,430
Dave Parnas points out that the easiest systems to deal with,

35
00:04:12,430 --> 00:04:21,760
the ones that engineers know how to cope with very well, are analogue systems where they operate within some safe operational range.

36
00:04:21,760 --> 00:04:26,170
And a small change in the inputs will cause a small change in the outputs.

37
00:04:26,170 --> 00:04:35,640
If you know that individual components are well behaved, then you can pretty much understand the whole system.

38
00:04:35,640 --> 00:04:47,460
Now, engineers have also learnt how to build digital systems that are repetitive. An example here is the CPU.

39
00:04:47,460 --> 00:04:52,050
This is a very large system which has lots of lots of different states.

40
00:04:52,050 --> 00:05:00,090
But because it's very repetitive, it's built up from small, repeated components that are simpler.

41
00:05:00,090 --> 00:05:10,290
You can analyse the individual components and then from the analysis of those individual components, make sense of the whole system.

42
00:05:10,290 --> 00:05:17,790
Now, the reason why software is difficult is that software is a problem of organised complexity.

43
00:05:17,790 --> 00:05:24,450
There's a large number of states, but they're not the result of some sort of repetition.

44
00:05:24,450 --> 00:05:31,920
They're just all unique, very different states. And it's not analogue, meaning that a small change

45
00:05:31,920 --> 00:05:36,630
in input can completely change the pattern of their behaviour.

46
00:05:36,630 --> 00:05:47,820
So just like in the case of Jane Jacobs' analysis of cities, here, we have systems that, not only you can't fully analyse them,

47
00:05:47,820 --> 00:05:57,780
but also there's no way to simplify and reduce the complexity. With a lot of effort,

48
00:05:57,780 --> 00:06:02,130
you can fully analyse increasingly bigger software systems.

49
00:06:02,130 --> 00:06:07,560
But once it gets beyond some threshold, it's just going to be too much.

50
00:06:07,560 --> 00:06:12,870
So that's why I think looking at urban planning is a really an interesting perspective,

51
00:06:12,870 --> 00:06:23,820
because it's exactly an area that is already learning, since 1960s, how to deal with the problems where you can't

52
00:06:23,820 --> 00:06:27,630
the complexity of the system.

53
00:06:27,630 --> 00:06:39,480
And Jane Jacobs wrote her book as a response to the developments in urban planning and city planning prior to the 1960s,

54
00:06:39,480 --> 00:06:48,780
Earlier theories, which were always trying to do some sort of simplification.

55
00:06:48,780 --> 00:06:57,180
Her counterpoint to those theories was saying the pseudoscience of city planning and its companion,

56
00:06:57,180 --> 00:07:03,420
the art of city design, have not yet broken with the specious comfort of wishes,

57
00:07:03,420 --> 00:07:12,900
familiar superstitions, oversimplifications and symbols, and have not yet embarked upon the adventure of probing the real world.

58
00:07:12,900 --> 00:07:20,010
Jane Jacobs was really seeing the current theories of the time as something that uses

59
00:07:20,010 --> 00:07:26,190
these oversimplifications that are just not really applicable to the real world.

60
00:07:26,190 --> 00:07:32,580
And when I look at some of the things that we do in programming systems, programming languages,

61
00:07:32,580 --> 00:07:43,890
I think we might be actually still in the era not yet embarked upon the adventure of probing the real world.

62
00:07:43,890 --> 00:07:56,610
Jane Jacobs was referring to various utopian urban planning ideas like Corbusier's Ville Radieuse or Ebenezer Howard's Garden City idea,

63
00:07:56,610 --> 00:08:08,040
which were all coming up with a reasonably, logically sounding, visions of how you organise a city by

64
00:08:08,040 --> 00:08:18,090
grouping various functions together and having large boulevards, where cars can get from any point to any other point.

65
00:08:18,090 --> 00:08:31,710
To balance for that, you'll have lots of different parks. All those theories sounded like they could possibly work, but in practise they didn't.

66
00:08:31,710 --> 00:08:41,310
And what Jane Jacobs was doing was that she was actually looking at cities that do work or places in cities that do work.

67
00:08:41,310 --> 00:08:51,540
Her book is this amazing analysis of little details in two places, in Greenwich Village, in New York and North and in Boston.

68
00:08:51,540 --> 00:08:56,550
She's looking at the street life, as she calls it.

69
00:08:56,550 --> 00:09:03,000
How the fact that there is mix of functions in the city contributes to the safety,

70
00:09:03,000 --> 00:09:08,820
because there's always people walking around from one place to another throughout the whole day.

71
00:09:08,820 --> 00:09:21,830
Her analysis is taking the places that, from her own personal experience, work and looking at why that's the case.

72
00:09:21,830 --> 00:09:30,890
In programming, I think we've got plenty of utopian programming system ideas that are based on a nice idea,

73
00:09:30,890 --> 00:09:38,300
but if you look at some of the some of the analysis that people have done, they actually prove to be more tricky.

74
00:09:38,300 --> 00:09:49,670
Abstraction is one of them. And there's a paper in recent Onward! Essays about fatal abstractions where this actually doesn't work.

75
00:09:49,670 --> 00:09:57,890
We all love information hiding because we think it will help maintainability of our systems,

76
00:09:57,890 --> 00:10:08,060
but again, there are counterexamples where information hiding prevents later evolution of a system.

77
00:10:08,060 --> 00:10:13,670
In programming languages, especially, we all love formal models,

78
00:10:13,670 --> 00:10:21,440
but just like the formal theories of urban planning prior to the 1960s,

79
00:10:21,440 --> 00:10:28,430
the formal models we use are often missing crucial aspects about the programming systems that we're actually dealing with.

80
00:10:28,430 --> 00:10:32,090
So, what is Jane Jacobs' answer to this problem?

81
00:10:32,090 --> 00:10:39,350
How should we actually understand complex systems and how should we design cities that work?

82
00:10:39,350 --> 00:10:49,040
For her, the key idea is really to understand the city as it is, as a real system with all its messiness and complexities.

83
00:10:49,040 --> 00:10:58,700
And she says, in the case of understanding cities, the most important habits of thought are first to think about processes;

84
00:10:58,700 --> 00:11:02,120
second, to work inductively; and third,

85
00:11:02,120 --> 00:11:12,350
to seek for unaverage clues involving very small quantities which reveal the way larger and more average quantities are operating.

86
00:11:12,350 --> 00:11:22,820
Her approach is to look at a very specific thing in the city and analyse it and see what are the more general lessons that we can learn from that.

87
00:11:22,820 --> 00:11:30,470
Her specific example, one that's very nice, is this chain of bookshops that operates all over New York

88
00:11:30,470 --> 00:11:38,570
and it has several branches that are all open until 10pm in the evening,

89
00:11:38,570 --> 00:11:43,520
except for one branch, I believe that was in Brooklyn downtown,

90
00:11:43,520 --> 00:11:49,820
which closes at something like 7pm. And that's one example that illustrates that,

91
00:11:49,820 --> 00:11:55,550
one aspect of the city is very different, because that's where,

92
00:11:55,550 --> 00:12:01,820
nobody is there after 7pm. There's nobody walking around to buy books.

93
00:12:01,820 --> 00:12:07,150
So that one simple example is actually...

94
00:12:07,150 --> 00:12:19,030
Reveals a bigger truth about the system. So my first call to action from this talk is that we should follow

95
00:12:19,030 --> 00:12:24,730
Jane Jacobs and study programming systems that actually work in their full complexity,

96
00:12:24,730 --> 00:12:33,880
starting from the small details that can reveal what is it about a system that really, really makes it work.

97
00:12:33,880 --> 00:12:42,640
And I think it's important to overstep our own assumptions and beliefs

98
00:12:42,640 --> 00:12:48,290
about what are the programming systems that work, because we all have our favourites.

99
00:12:48,290 --> 00:12:58,870
But if you look at some of the interesting technologies that actually are working in the industry like JavaScript,

100
00:12:58,870 --> 00:13:11,120
there might be interesting reasons why that works that are beyond the scope of what we normally talk about in programming languages research.

101
00:13:11,120 --> 00:13:17,630
Another area where I think we can learn from urban planning is related to conceptual coherence,

102
00:13:17,630 --> 00:13:29,570
which is a term coined by Fred Brooks in the Mythical Man-Month. Conceptual coherence is basically this idea that a system is fully comprehensible.

103
00:13:29,570 --> 00:13:38,480
Fred Brooks says that conceptual coherence dictates that the design must proceed from one mind or from a very small number of agreeing,

104
00:13:38,480 --> 00:13:45,320
resonant minds. The point here is that if you are building a large system,

105
00:13:45,320 --> 00:13:55,040
if it is designed by multiple people who will all understand it differently, then it will not be conceptually coherent.

106
00:13:55,040 --> 00:14:03,620
It will not be comprehensible. So there's this sort of mismatch between the user who has to be able to make sense of it,

107
00:14:03,620 --> 00:14:08,360
and potentially a large number of programmers who are building the system.

108
00:14:08,360 --> 00:14:14,260
Or as Fred Brooks says, any product that is sufficiently big must be conceptually coherent to

109
00:14:14,260 --> 00:14:19,070
a single mind of the user, and at the same time, designed by many minds.

110
00:14:19,070 --> 00:14:26,360
So for Fred Brooks, the whole issue is how do you actually design the system so that it all makes sense together?

111
00:14:26,360 --> 00:14:33,230
It's all understandable using some reasonable rules or some logic behind it.

112
00:14:33,230 --> 00:14:39,500
And for him, the issue is that this works if it comes from a single mind,

113
00:14:39,500 --> 00:14:47,390
but once you start building things that are too big for a single mind, then it's harder to achieve.

114
00:14:47,390 --> 00:14:55,520
Now, if you look at cities and urban planning, then there's different kinds of cities.

115
00:14:55,520 --> 00:15:02,900
I have two example maps here. One is more or less conceptually coherent.

116
00:15:02,900 --> 00:15:14,990
So this is Manhattan, New York, where you have the nice, logical grid with street numbers that are easy to understand.

117
00:15:14,990 --> 00:15:16,850
And on the other hand,

118
00:15:16,850 --> 00:15:27,530
I have a map of Prague which has evolved very much through an evolutionary process and has no overall structure,

119
00:15:27,530 --> 00:15:33,080
at least not in the downtown part that you can see here.

120
00:15:33,080 --> 00:15:39,200
Does this mean that making sense of Prague is impossible?

121
00:15:39,200 --> 00:15:44,760
Here I'm going to refer to James Scott's Seeing Like a State.

122
00:15:44,760 --> 00:15:53,480
And Scott points out that the fact that the layout of the city, like Bruges, having developed without any overall design,

123
00:15:53,480 --> 00:15:59,960
lacks consistent geometric logic does not mean that it was at all confusing to its inhabitants.

124
00:15:59,960 --> 00:16:04,760
Scott is looking at the design of cities and urban planning as well.

125
00:16:04,760 --> 00:16:09,860
And he points out that you don't really need that consistency

126
00:16:09,860 --> 00:16:18,160
and coherency to make sense of a city. And in fact,

127
00:16:18,160 --> 00:16:28,120
the relative ineligibility of some urban neighbourhoods has provided a vital margin of political safety from control by outside elites.

128
00:16:28,120 --> 00:16:39,790
So not only is the messiness of a city something that's not a problem to its inhabitants, but in some cases is actually quite valuable.

129
00:16:39,790 --> 00:16:53,980
It's helped them in many ways to confuse the outsiders who are trying to impose various structures and

130
00:16:53,980 --> 00:17:03,490
control over the city. So the lack of coherence isn't necessarily a problem, but of course,

131
00:17:03,490 --> 00:17:09,850
the inhabitants, the people who live in the system have to be able to understand it.

132
00:17:09,850 --> 00:17:19,770
In cities, this is achieved in various ways. One useful analysis of how people actually navigate around cities,

133
00:17:19,770 --> 00:17:25,780
how this works, is a book called The Image of the City by Kevin Lynch.

134
00:17:25,780 --> 00:17:37,690
And in that, Lynch points out that there are various structures in a city like paths or landmarks that are used for navigation.

135
00:17:37,690 --> 00:17:46,360
So you might have a landmark like a castle that's visible from many different parts of the city, and you will immediately know where roughly you are.

136
00:17:46,360 --> 00:17:52,270
You have different districts which are distinguished by a different style of buildings.

137
00:17:52,270 --> 00:18:04,450
You have various paths through the city, which could be a road or a cycle path or something like an underground network.

138
00:18:04,450 --> 00:18:11,890
And I think this is something that's very much relevant to programming systems as well, because if you have a very large software system,

139
00:18:11,890 --> 00:18:17,470
you can't really have this precise map with every single street on a grid to

140
00:18:17,470 --> 00:18:23,260
navigate and understand every single aspect of the system all at once.

141
00:18:23,260 --> 00:18:30,100
But what you might very well have is a system where you know some general districts,

142
00:18:30,100 --> 00:18:35,530
some general parts of it, and you can navigate, you know how to navigate between them.

143
00:18:35,530 --> 00:18:42,190
You know how they're related through something like the metro system in Prague.

144
00:18:42,190 --> 00:18:52,360
And that gives you a basic structure for moving around, getting understanding how different components might relate.

145
00:18:52,360 --> 00:18:57,190
There goes my second call to action of the task,

146
00:18:57,190 --> 00:19:04,750
which is that I think we should start thinking about understandability, not about conceptual coherence.

147
00:19:04,750 --> 00:19:12,790
And by understandability, I really mean something that's much more dynamic then what we see in,

148
00:19:12,790 --> 00:19:21,940
say, conceptual coherence. With conceptual coherence, the idea is you'll read the documentation and then you'll suddenly understand the whole system.

149
00:19:21,940 --> 00:19:27,880
I think understandability is something that can come more from interacting with the system,

150
00:19:27,880 --> 00:19:34,840
from feedback and from a dynamic process where, just like when you live in a city,

151
00:19:34,840 --> 00:19:42,760
you might know some neighbourhood, and when you need to explore some other neighbourhoods, you have ways for doing that.

152
00:19:42,760 --> 00:19:52,470
And I think that might be a much more interesting and useful way of dealing with complexity in large software systems.

153
00:19:52,470 --> 00:20:02,910
The third point I want to talk about is about adaptable software, and this is inspired by Stewart Brand's work on how buildings learn,

154
00:20:02,910 --> 00:20:08,670
which is this analysis of what happens to buildings once they're built,

155
00:20:08,670 --> 00:20:15,850
looking at different kinds of buildings and pointing out that the evolution is different for each of those.

156
00:20:15,850 --> 00:20:21,860
And Stewart Brand starts by pointing out that almost no buildings adapt

157
00:20:21,860 --> 00:20:27,400
well. They're designed not to adopt, budgeted and financed not to, constructed not to,

158
00:20:27,400 --> 00:20:35,620
administered not to, maintained not to, regulated and taxed not to, and even remodelled not to.

159
00:20:35,620 --> 00:20:44,260
But all buildings adapt anyway, however poorly, because the usages in and around them are changing constantly.

160
00:20:44,260 --> 00:20:52,060
And when you read this, I think you will immediately see why I'm bringing this into a discussion about software.

161
00:20:52,060 --> 00:21:03,280
Because software, I think when we design software, we are very often designing it for the situation that we currently have at hand.

162
00:21:03,280 --> 00:21:13,180
Of course, there's various hopes that our programming languages allow the right kind of extensibility,

163
00:21:13,180 --> 00:21:20,640
but we never really know in what directions is the system going to evolve and change.

164
00:21:20,640 --> 00:21:33,550
And of course, just like buildings, software will adapt, however poorly, because the usages and the context and the environment around it is changing.

165
00:21:33,550 --> 00:21:38,770
So what is Stewart Brand saying that we should do?

166
00:21:38,770 --> 00:21:44,500
He's actually talking about different kinds of different kinds of buildings and for different kinds of buildings,

167
00:21:44,500 --> 00:21:47,170
you might have different kinds of strategies.

168
00:21:47,170 --> 00:21:54,190
But one of the, two of the points in the book that I find very interesting that I think are equally

169
00:21:54,190 --> 00:22:03,650
applicable to software are, first, the point that new buildings teach bad maintenance habits.

170
00:22:03,650 --> 00:22:11,020
And that's because when you build a new building, it works, and for several years it will need no maintenance.

171
00:22:11,020 --> 00:22:18,160
And so the inhabitants are going to stop paying attention until eventually things will start breaking.

172
00:22:18,160 --> 00:22:23,350
And then they don't know. They don't have the habits. They don't know how the maintenance should be done.

173
00:22:23,350 --> 00:22:28,450
And I think in software, this is equally relevant.

174
00:22:28,450 --> 00:22:35,470
We do actually have this idea of chaos monkey for developing distributed systems,

175
00:22:35,470 --> 00:22:42,220
which I think is part of the answer here of teaching good maintenance.

176
00:22:42,220 --> 00:22:49,990
The other interesting point made by Stewart Brand is that the maintainability very much depends on materials

177
00:22:49,990 --> 00:22:58,180
He's very much arguing for materials that have this quality that they look bad before they go bad.

178
00:22:58,180 --> 00:23:04,030
So a wooden siding on a house is an example, because when you look at the house,

179
00:23:04,030 --> 00:23:10,930
you will immediately see in what condition the siding is and you will see that

180
00:23:10,930 --> 00:23:15,760
that this is something that's going to break and not work very well,

181
00:23:15,760 --> 00:23:19,810
much earlier than it actually breaks.

182
00:23:19,810 --> 00:23:28,840
And when houses instead get covered with vinyl siding, that is something that looks great.

183
00:23:28,840 --> 00:23:34,240
But you don't see that the surface behind it is slowly rotting.

184
00:23:34,240 --> 00:23:47,720
So this is, I think, an interesting challenge for software. The other interesting point from Stewart Brand is that one particular kind of architecture

185
00:23:47,720 --> 00:23:55,070
that's called vernacular or unselfconscious architecture works quite differently.

186
00:23:55,070 --> 00:24:02,690
This is when you have things like a New England farmhouse,

187
00:24:02,690 --> 00:24:09,830
which is built basically by doing exactly the same thing as all the other farmhouses in the

188
00:24:09,830 --> 00:24:19,700
area with some minor tweaks by the current owner because they have some specific requirements.

189
00:24:19,700 --> 00:24:29,210
But you're always basically following the same structure and making adaptations over the generations.

190
00:24:29,210 --> 00:24:34,100
So that's what you could call design without the reinvention of the farm,

191
00:24:34,100 --> 00:24:40,340
because the basic form always stays the same and it's just small adaptations.

192
00:24:40,340 --> 00:24:49,220
In contrast, when we are building software, we're pretty much always starting by reinventing the form.

193
00:24:49,220 --> 00:24:58,340
That, I think is an interesting opportunity, how could we design software so that we are not reinventing the form from scratch,

194
00:24:58,340 --> 00:25:03,170
but we're sort of adapting or building on what's already there.

195
00:25:03,170 --> 00:25:08,510
And I think this actually does happen in some areas of software engineering.

196
00:25:08,510 --> 00:25:17,090
I think it happens in areas where you have large systems that are mostly evolved or applied by configuration,

197
00:25:17,090 --> 00:25:23,690
by sort of making all those small tweaks, or in systems that make it very easy

198
00:25:23,690 --> 00:25:32,660
to copy paste and reuse existing materials like HyperCard or the 1990s web.

199
00:25:32,660 --> 00:25:45,050
So my third call to action from the talk is to really think about the materials and the

200
00:25:45,050 --> 00:25:54,800
the stuff from which we are building software and invent materials that age well and allow adaptation.

201
00:25:54,800 --> 00:25:59,540
So by that I mean that allow adaptation.

202
00:25:59,540 --> 00:26:10,230
I think that involves a lot of having access to how the thing is built so that it can be modified without having to be completely rewritten.

203
00:26:10,230 --> 00:26:15,800
The question about materials that age well... I don't have a don't have an answer to that one.

204
00:26:15,800 --> 00:26:20,700
So this is still an open question.

205
00:26:20,700 --> 00:26:30,360
So my final point is, how do we actually get to a point where architecture, design and urban planning is the way we think about software.

206
00:26:30,360 --> 00:26:38,040
I think this is already a very nice and very useful way of thinking about software.

207
00:26:38,040 --> 00:26:43,260
But what is it going to take for this to become mainstream?

208
00:26:43,260 --> 00:26:49,680
And here I think we can draw an interesting parallel with the history of software engineering,

209
00:26:49,680 --> 00:26:59,430
where the way of thinking changes not so much when someone comes up with a new idea about how to think about software,

210
00:26:59,430 --> 00:27:07,620
but more when there's some outside external circumstance that makes that change happen.

211
00:27:07,620 --> 00:27:18,990
In 1960s and 70s, the birth of software engineering was really a response to the increasing computer availability when more and more companies

212
00:27:18,990 --> 00:27:27,550
needed to build software and the small number of expert programmers that were available wasn't enough to do that.

213
00:27:27,550 --> 00:27:36,990
So they needed to sort of borrow the factory and production model to come up with a way of building software that scales more.

214
00:27:36,990 --> 00:27:44,700
In 1990s, the various lightweight software development methodologies were again a response to

215
00:27:44,700 --> 00:27:55,050
the fact that various market forces were making software development faster.

216
00:27:55,050 --> 00:28:05,490
You have to build an application to respond to what your competition was doing in a much shorter time frame.

217
00:28:05,490 --> 00:28:09,870
And that required a different thinking about software.

218
00:28:09,870 --> 00:28:20,910
And I think for architecture, design and urban planning, we might just have to wait for another change in the socio-technological context.

219
00:28:20,910 --> 00:28:24,960
So keep an eye on what's happening in the industry.

220
00:28:24,960 --> 00:28:31,920
And hopefully at some point soon there will be a change that really naturally

221
00:28:31,920 --> 00:28:38,580
makes us think of software as more like an architecture, design and urban planning.

222
00:28:38,580 --> 00:28:42,131
Thank you.
