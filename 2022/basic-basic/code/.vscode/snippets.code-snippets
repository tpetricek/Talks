{
  "Step 2 - Run command helpers": {
    "prefix": "step-2-helpers",
    "body": [
      "// Get program commands as sorted list",
			"let statements () = ",
      "  [ for (KeyValue(k,v)) in state.Program -> Some k, v ] ",
      "  |> Seq.sortBy fst ",
			"",
			"// Find the next line (if there is one) and run it",
      "let next state = ",
      "  match ln with ",
      "  | None -> state",
      "  | Some ln -> ",
      "      let next = statements() |> Seq.tryFind (fun (l, _) -> l > Some ln)",
      "      match next with ",
      "      | None -> state",
      "      | Some next -> runCommand state next",
    ]
  },
  "Step 4 - Get number function": {
    "prefix": "step-4-get-number",
    "body": [
      "let getNumber = function",
      "  | Number n -> n",
      "  | _ -> failwith \"Not a number\""
    ]
  },
  "Step 5 - Parser.fs": {
    "prefix": "step-5-parser",
    "body": [
      "module Basic.Parser",
      "open Basic.Domain",
      "",
      "type Token =",
      "  | Equals",
      "  | Ident of string",
      "  | Operator of char",
      "  | Bracket of char",
      "  | Numeral of float",
      "  | Text of string",
      "",
      "let str rcl = System.String(Array.rev(Array.ofSeq rcl))",
      "let isLetter c = (c >= 'A' && c <= 'Z') || c = '$'",
      "let isOp c = \"+-*/<>\".Contains(string c)",
      "let isBracket c = \"()\".Contains(string c)",
      "let isNumber c = (c >= '0' && c <= '9')",
      "",
      "let rec tokenize toks = function",
      "  | c::cs when isLetter c -> ident toks [c] cs",
      "  | c::cs when isNumber c -> number toks [c] cs",
      "  | c::cs when isOp c -> tokenize ((Operator c)::toks) cs",
      "  | c::cs when isBracket c -> tokenize ((Bracket c)::toks) cs",
      "  | '='::cs -> tokenize (Equals::toks) cs",
      "  | '\"'::cs -> strend toks [] cs",
      "  | ' '::cs -> tokenize toks cs",
      "  | [] -> List.rev toks",
      "  | cs -> failwithf \"Cannot tokenize: %s\" (str (List.rev cs))",
      "",
      "and strend toks acc = function",
      "  | '\"'::cs -> tokenize (Text(str acc)::toks) cs",
      "  | c::cs -> strend toks (c::acc) cs",
      "  | [] -> failwith \"End of string not found\"",
      "",
      "and ident toks acc = function",
      "  | c::cs when isLetter c -> ident toks (c::acc) cs",
      "  | '$'::input -> tokenize (Ident(str ('$'::acc))::toks) input",
      "  | input -> tokenize (Ident(str acc)::toks) input",
      "",
      "and number toks acc = function",
      "  | c::cs when isNumber c -> number toks (c::acc) cs",
      "  | '.'::cs when not (List.contains '.' acc) -> number toks ('.'::acc) cs",
      "  | input -> tokenize (Numeral(float (str acc))::toks) input",
      "",
      "let tokenizeString s = tokenize [] (List.ofSeq s)",
      "",
      "let rec parseBinary left = function",
      "  | (Operator o)::toks -> ",
      "      let right, toks = parseExpr toks",
      "      Binary(o, left, right), toks",
      "  | Equals::toks -> ",
      "      let right, toks = parseExpr toks",
      "      Binary('=', left, right), toks",
      "  | toks -> left, toks",
      "",
      "and parseExpr = function",
      "  | (Text s)::toks -> parseBinary (Literal(String s)) toks",
      "  | (Numeral n)::toks -> parseBinary (Literal(Number(decimal n))) toks",
      "  | (Ident i)::(Bracket '(')::toks ->",
      "      let arg, toks = parseExpr toks ",
      "      match toks with ",
      "      | (Bracket ')')::toks -> Function(i, arg), toks",
      "      | _ -> ",
      "        let bin, toks = parseBinary arg toks",
      "        Function(i, bin), toks",
      "  | (Ident v)::toks -> parseBinary (Variable v) toks",
      "  | toks -> failwithf \"Parsing expr failed. Unexpected: %A\" toks",
      "",
      "let rec parseInput toks = ",
      "  let line, toks = ",
      "    match toks with",
      "    | (Numeral ln)::toks -> Some(int ln), toks",
      "    | _ -> None, toks",
      "  match toks with ",
      "  | (Ident \"RUN\")::[] -> line, Run",
      "  | (Ident \"LIST\")::[] -> line, List",
      "  | (Ident \"GOTO\")::(Numeral lbl)::[] -> line, Goto(int lbl)",
      "  | (Ident \"INPUT\")::(Ident var)::[] -> line, Input(var)",
      "  | (Ident \"IF\")::toks -> ",
      "      let arg1, toks = parseExpr toks",
      "      match toks with ",
      "      | (Ident \"GOTO\")::(Numeral ln)::[] ->",
      "          line, If(arg1, int ln)      ",
      "      | _ ->",
      "          failwithf \"Parsing IF failed. Expected GOTO.\"",
      "  | (Ident \"PRINT\")::toks -> ",
      "      let arg, toks = parseExpr toks",
      "      if toks <> [] then failwithf \"Parsing PRINT failed. Unexpected: %A\" toks",
      "      line, Print(arg)",
      "  | (Ident id)::Equals::toks ->",
      "      let arg, toks = parseExpr toks",
      "      if toks <> [] then failwithf \"Parsing = failed. Unexpected: %A\" toks",
      "      line, Assign(id, arg)",
      "  | _ -> failwithf \"Parsing command failed. Unexpected: %A\" toks  ",      
    ]
  },
  "Step 4 - Eval expression other cases": {
    "prefix": "step-4-eval-expr",
    "body": [
      "  | Function(\"INT\", e) ->",
      "      Number(decimal (int (getNumber (evalExpression state e))))",
      "  | Binary('*', l, r) -> ",
      "      Number(getNumber (evalExpression state l) * ",
      "        getNumber(evalExpression state r))",
      "  | Binary('<', l, r) -> ",
      "      Bool(getNumber (evalExpression state l) < ",
      "        getNumber(evalExpression state r))",
      "  | Binary('>', l, r) -> ",
      "      Bool(getNumber (evalExpression state l) > ",
      "        getNumber(evalExpression state r))",
      "  | Binary('=', l, r) -> ",
      "      Bool(getNumber (evalExpression state l) = ",
      "        getNumber(evalExpression state r))",
      "  | Binary _ -> failwith \"Unsupported operator\"",
      "  | Function _ -> failwith \"Unsupported function\"",
    ]
  },
  "Step 5 - Recursive input loop": {
    "prefix": "step-5-recursive-loop",
    "body": [
      "let rec loop state = async {",
      "  let! line = input |> awaitObservable",
      "  let cmd = parseInput (tokenizeString line)",
      "  let! newState = acceptInput state cmd ",
      "  return! loop newState }"
    ]
  },
  "Step 4 - Guessign game demo": {
    "prefix": "step-4-guessing-game",
    "body": [
      "let lines = ",
      "  [ \"10 Q=1+INT(100*RND(1))\"",
      "    \"20 N=0\"",
      "    \"30 PRINT \\\"GUESS A NUMBER BETWEEN 1 AND 100!\\\"\"",
      "    \"40 INPUT G\"",
      "    \"50 IF G=Q GOTO 130\"",
      "    \"60 N=N+1\"",
      "    \"70 IF N=7 GOTO 120\"",
      "    \"80 IF G<Q GOTO 100\"",
      "    \"90 IF G>Q GOTO 110\"",
      "    \"100 PRINT \\\"NOT ENOUGH! TRY AGAIN\\\"\"",
      "    \"101 GOTO 30\"",
      "    \"110 PRINT \\\"TOO MUCH! TRY AGAIN\\\"\"",
      "    \"111 GOTO 30\"",
      "    \"120 PRINT \\\"YOU LOST!\\\"\"",
      "    \"121 GOTO 150\"",
      "    \"130 PRINT \\\"YOU WON!\\\"\"",
      "    \"150 PRINT \\\"THANKS FOR PLAYING\\\"\" ]",
      "",
      "let guess = ",
      "  [ Some 10, Assign(\"Q\", Binary('+', ",
      "      Function(\"INT\",Binary('*', Function(\"RND\", Literal(Number 1M)), ",
      "        Literal(Number 100M))), Literal(Number 1M)))",
      "    Some 20, Assign(\"N\", Literal(Number 0M))",
      "    Some 30, Print(Literal(String \"GUESS A NUMBER BETWEEN 1 AND 100!\"))",
      "    Some 40, Input \"G\"",
      "    Some 50, If(Binary('=', Variable \"G\", Variable \"Q\"), 130)",
      "    Some 60, Assign(\"N\", Binary('+', Variable(\"N\"), Literal(Number 1M)))",
      "    Some 70, If(Binary('=', Variable \"N\", Literal(Number 7M)), 120)",
      "    Some 80, If(Binary('<', Variable \"G\", Variable \"Q\"), 100)",
      "    Some 90, If(Binary('>', Variable \"G\", Variable \"Q\"), 110)",
      "    Some 100, Print(Literal(String \"NOT ENOUGH! TRY AGAIN\"))",
      "    Some 101, Goto 30",
      "    Some 110, Print(Literal(String \"TOO MUCH! TRY AGAIN\"))",
      "    Some 111, Goto 30",
      "    Some 120, Print(Literal(String \"YOU LOST!\"))",
      "    Some 121, Goto 150",
      "    Some 130, Print(Literal(String \"YOU WON!\"))",
      "    Some 150, Print(Literal(String \"THANKS FOR PLAYING\")) ",
      "    None, List",
      "    None, Run ]"
    ]
  },
  "Step 3 - Basic Hello world": {
    "prefix": "step-3-hello-world",
    "body": [
      "// DOMAIN MODEL",
      "",
      "type Value = ",
      "  | String of string",
      "",
      "type Expression = ",
      "  | Literal of Value",
      "",
      "type Command = ",
      "  | Print of Expression",
      "  | Goto of int",
      "  | Run",
      "",
      "// EVALUATOR",
      "",
      "type State = ",
      "  { Program : Map<int, Command> }",
      "  ",
      "let evalExpression = function",
      "  | Literal(v) -> v",
      "",
      "let toString = function",
      "  | String s -> s",
      "",
      "let rec runCommand state (ln, cmd) = ",
      "  // Get program commands as sorted list",
      "  let statements () = ",
      "    [ for (KeyValue(k,v)) in state.Program -> Some k, v ] ",
      "    |> Seq.sortBy fst ",
      "  ",
      "  // Find the next line (if there is one) and run it",
      "  let next state = ",
      "    match ln with ",
      "    | None -> state",
      "    | Some ln -> ",
      "        let next = statements() |> Seq.tryFind (fun (l, _) -> l > Some ln)",
      "        match next with ",
      "        | None -> state",
      "        | Some next -> runCommand state next",
      "",
      "  match cmd with",
      "  | Run ->",
      "      runCommand state (Seq.head (statements ()))",
      "  | Goto ln -> ",
      "      runCommand state (Some ln, state.Program.[ln])",
      "  | Print e -> ",
      "      printfn \"%s\" (toString (evalExpression e))",
      "      next state",
      "",
      "let acceptInput state (ln, cmd) = ",
      "  match ln with ",
      "  | Some ln -> { state with Program = state.Program.Add(ln, cmd) }",
      "  | None -> runCommand state (None, cmd)",
      "",
      "// SAMPLE ",
      "",
      "let hello = ",
      "  [ Some 10, Print(Literal(String \"HELLO WORLD\")) ",
      "    Some 20, Goto 10 ",
      "    None, Run ]    ",
      "",
      "let mutable state = { Program = Map.empty }",
      "for cmd in hello do",
      "  state <- acceptInput state cmd"
    ]
  }

  // "Print to console": {
  //   "scope": "javascript,typescript",
  //   "prefix": "log",
  //   "body": [
  //     "console.log('$1');",
  //     "$2"
  //   ],
  //   "description": "Log output to console"
  // }
}